## План тотальной актуализации Swagger (`/api/v2/docs`)

### 1. Общие цели и критерии готовности

- Swagger должен:
  - Описывать **все HTTP‑методы** всех контроллеров (все модули NestJS).
  - Иметь **примеры запросов и ответов для каждого метода**, включая типичные ошибки.
  - Совпадать с **фактической реализацией** (URL, метод, структура JSON, коды статуса).
  - Быть **полезным фронтенду**: по одному взгляду на `/api/v2/docs` можно правильно написать запрос.

Критерии готовности:
- Для каждого контроллера:
  - Все методы имеют `@ApiOperation` с понятным `summary` и, при необходимости, `description`.
  - Определены `@ApiResponse` / `@ApiOkResponse` / `@ApiCreatedResponse` / `@ApiNoContentResponse` с корректными `type`/`schema` и примерами.
  - Ошибки (`400/401/403/404/409/422/...`) явно описаны через `@ApiBadRequestResponse`, `@ApiUnauthorizedResponse`, `@ApiForbiddenResponse`, `@ApiNotFoundResponse`, `@ApiConflictResponse` и т.п.
  - Все DTO помечены `@ApiProperty` / `@ApiPropertyOptional` с адекватными `description` и `example`.

---

### 2. Поэтапный план работ

#### Этап 1. Аудит текущего Swagger

1. **Сбор списка контроллеров**
   - Пройти `backend/src/modules/**` и собрать список всех `*.controller.ts`.
   - Сгруппировать по доменам (auth, users, masters, services, posts, friends, favorites, reviews, bookings, chats, notifications, search, analytics, system).

2. **Проверка покрытия Swagger‑декораторами**
   - Для каждого контроллера зафиксировать:
     - Наличие `@ApiTags`, `@ApiBearerAuth`/`@Public`.
     - Для каждого метода:
       - Есть ли `@ApiOperation`.
       - Есть ли `@ApiResponse`/`@ApiOkResponse`/`@ApiCreatedResponse` и т.п.
       - Есть ли `@ApiParam`/`@ApiQuery`, где используются path/query‑параметры.
   - Отметить «проблемные» контроллеры:
     - Без примеров.
     - Без описаний ошибок.
     - Где заголовки/описания явно устарели относительно кода.

Результат этапа: список контроллеров с уровнем покрытия (полное / частичное / минимальное).

---

#### Этап 2. Базовое выравнивание всех контроллеров

Цель: привести **весь API** хотя бы к минимальному, но корректному описанию.

Для каждого контроллера:

1. **Добавить/уточнить `@ApiTags` и `@ApiBearerAuth`**
   - Убедиться, что тег совпадает с тегами, объявленными в `main.ts` (`auth`, `users`, `masters`, `services`, `posts`, `friends`, `Subscriptions`, `Favorites`, `Reviews`, `Bookings`, `chats`, `notifications`, `search`, `analytics` и т.п.).
   - Для публичных эндпоинтов добавить `@Public()` и *не* навешивать `@ApiBearerAuth` на сам метод (если применяется только на уровне класса).

2. **Задать `@ApiOperation` для каждого метода**
   - Короткий, но точный `summary`: действие + сущность (например, «Создать бронирование», «Получить услуги мастера», «Проверить подписку»).
   - При необходимости `description` с деталями (фильтрация, особенности privacy, пагинация).

3. **Базовые успешные ответы**
   - Для методов чтения: `@ApiOkResponse({ description, type })` или `schema` для обёрток вида `{ data, meta }`.
   - Для `POST`: `@ApiCreatedResponse({ description, type })`.
   - Для `PATCH/PUT`: `@ApiOkResponse({ description, type })`.
   - Для `DELETE`: `@ApiNoContentResponse` (если ничего не возвращаем) либо `@ApiOkResponse`, если возвращаем объект/сообщение.

Результат этапа: у всех методов есть хотя бы один корректный успешный ответ и `@ApiOperation`.

---

#### Этап 3. Добавление подробных примеров (success)

Цель: предоставить фронтенду **реалистичные JSON‑примеров** для каждого метода.

Подход:

1. **DTO как источник правды**
   - Для всех DTO (request/response) убедиться, что:
     - Все важные поля имеют `@ApiProperty`/`@ApiPropertyOptional` с `description` и `example`.
     - Примеры основаны на сид‑данных и реальных сценариях (UUID из сидов, реальные тексты, структуры `media`, `location`, `category_ids`, `service_ids` и т.д.).

2. **Примеры на уровне `@ApiResponse`**
   - Для каждого метода задать:
     - `examples` (если `type` указан) или `schema.example` (для сложных обёрток).
     - Для коллекций с пагинацией — структуру:
       ```json
       {
         "data": [ { ...dtoExample } ],
         "meta": { "page": 1, "limit": 20, "total": 36, "totalPages": 2 }
       }
       ```
   - Для командных методов (create/update/delete) — пример JSON того, что реально возвращает API (например, созданный объект с заполненными ID и датами).

3. **Модульные приоритеты (но покрыть все)**
   - Особенно детальные примеры сделать для:
     - `auth` (login/register/refresh).
     - `users` (профиль, смена настроек).
     - `masters` + `services` + `categories`.
     - `posts` + `likes` + `comments` + `reposts`.
     - `friends` + `subscriptions` + `favorites`.
     - `bookings` + `reviews`.
   - Для менее критичных модулей (notifications, analytics, internal tools) — тоже добавить примеры, но можно чуть менее подробные, чтобы не раздувать доку.

Результат этапа: у каждого эндпоинта есть «happy path» пример ответа (и при необходимости запроса).

---

#### Этап 4. Описание ошибок и пограничных случаев

Цель: фронтенд заранее знает, какие **ошибки и в каком формате** придут.

1. **Типовые ошибки из кода**
   - Для каждого метода проанализировать выбрасываемые исключения:
     - `BadRequestException` → `400`
     - `UnauthorizedException` → `401`
     - `ForbiddenException` → `403`
     - `NotFoundException` → `404`
     - `ConflictException` → `409`
     - `UnprocessableEntityException` → `422` (если используется)
   - Добавить соответствующие `@ApiXXXResponse({ description, schema/example })`.

2. **Единый формат ошибок**
   - Учитывая глобальное описание в `main.ts`, использовать в примерах структуру:
     ```json
     {
       "statusCode": 404,
       "message": "Post not found",
       "error": "Not Found"
     }
     ```
   - Для валидационных ошибок — пример массива сообщений, если так формируется ответ.

3. **Особые кейсы**
   - Подписки: `409 Already subscribed`, `404 Target user not found`.
   - Лайки/репосты: `409 Already liked/reposted`.
   - Бронирования/отзывы: `400 Booking not completed`, `409 Review already exists`.
   - Privacy: `403 Access denied` для постов «только для друзей» или приватных.

Результат этапа: для каждого метода есть явно задокументированные основные ошибки с примерами.

---

#### Этап 5. Сквозная проверка и доработка описаний

1. **Проверка `/api/v2/docs` глазами фронта**
   - Пройти по всем тегам:
     - Проверить, что названия и описания тегов понятны и логичны.
     - Убедиться, что «основные сценарии» видны сразу (например, create/update/list для каждой сущности).
   - Проверить, что:
     - в параметрах (path/query/body) нет рассинхрона с кодом;
     - типы и форматы (строки/числа/UUID/даты) совпадают;
     - примеры не содержат очевидных опечаток или нереалистичных значений.

2. **Микроулучшения UX Swagger UI**
   - При необходимости скорректировать:
     - порядок тегов;
     - названия тегов (чтобы соответствовали использованию на фронте);
     - описания в `main.ts` (overview, особенности аутентификации и пагинации).

Результат этапа: Swagger‑дока выглядит как «источник правды» и удобный справочник для фронтенда.

---

### 3. Финальное тестирование

1. **Smoke‑тесты эндпоинтов**
   - Через Swagger UI или Postman:
     - Пройтись по основным методам каждого тега (auth, users, masters, services, posts, friends, subscriptions, favorites, bookings, reviews, chats, notifications).
     - Убедиться, что:
       - пример запроса из Swagger действительно работает без правок (кроме токена);
       - фактический ответ совпадает по структуре с примером в доке (допустимы только отличия по значениям).

2. **Проверка фронтом**
   - Дать фронтенд‑разработчику ориентироваться только на `/api/v2/docs` для пары задач (например, создать пост, подписаться, получить услуги мастера).
   - Собрать обратную связь, при необходимости точечно улучшить описания/примеры.

3. **Документация процесса**
   - В `README_LOCAL.md` или отдельном документе в `docs/` кратко описать:
     - как обновлять Swagger при изменении API;
     - требования к DTO и контроллерам (обязательные декораторы и примеры);
     - ссылку на `/api/v2/docs` как на основной источник правды для фронтенда.

