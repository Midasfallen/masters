# Примеры планов с делегированием и MCP

Коллекция реальных примеров планов с автоматическим делегированием субагентам и использованием MCP серверов.

---

## Пример 1: Создание нового модуля (Backend + Database + Testing + Documentation)

```markdown
# План: Создание модуля Premium Subscriptions

## Анализ задачи
- Тип задачи: Backend + Database + Testing + Documentation
- Необходимые агенты: Database Agent, Backend Agent, Testing Agent, Documentation Agent
- Критичные операции: Postgres (миграции), Git (коммиты), Memory (сохранение контекста)
- Оценка времени: 6-8 часов

## План выполнения

### Шаг 1: [Database Agent] Создание миграции для таблицы premium_subscriptions
КОНТЕКСТ:
- Связанные файлы:
  - backend/src/database/migrations/
- Похожие паттерны:
  - backend/src/modules/users/entities/user.entity.ts
- Документация:
  - docs/technical/Database.md
- Зависимости:
  - Таблица users должна существовать

ТРЕБОВАНИЯ:
- Создать таблицу premium_subscriptions с полями:
  - id (UUID, primary key)
  - user_id (UUID, foreign key на users)
  - tier (enum: basic, premium, pro)
  - status (enum: active, cancelled, expired)
  - billing_period (enum: monthly, yearly)
  - started_at (timestamp)
  - expires_at (timestamp)
  - created_at, updated_at (timestamps)
- Добавить индексы на user_id и status
- Добавить unique constraint на user_id (один активный subscription на пользователя)

MCP ИСПОЛЬЗОВАНИЕ:
- Postgres MCP: проверка структуры таблицы users перед созданием foreign key
- Postgres MCP: проверка существующих enum типов перед созданием новых
- Git MCP: проверка статуса перед коммитом миграции

КРИТЕРИИ ВАЛИДАЦИИ:
- Миграция выполняется без ошибок
- Таблица создана с правильной структурой
- Индексы и constraints созданы корректно
- Foreign key работает правильно

### Шаг 2: [Backend Agent] Создание модуля premium-subscriptions
КОНТЕКСТ:
- Связанные файлы:
  - backend/src/modules/premium-subscriptions/
- Похожие паттерны:
  - backend/src/modules/bookings/ (для паттерна модуля)
- Документация:
  - docs/technical/TechSpec.md
  - docs/api/premium-subscriptions.md (создать)

ТРЕБОВАНИЯ:
- Создать premium-subscriptions.module.ts
- Создать premium-subscriptions.controller.ts с endpoints:
  - GET /premium/subscription (текущая подписка)
  - GET /premium/plans (доступные планы)
  - POST /premium/subscription (создание подписки)
  - PATCH /premium/subscription (обновление подписки)
  - DELETE /premium/subscription (отмена подписки)
- Создать premium-subscriptions.service.ts с бизнес-логикой
- Создать DTOs: CreateSubscriptionDto, UpdateSubscriptionDto
- Добавить Swagger документацию для всех endpoints
- Добавить валидацию через class-validator

MCP ИСПОЛЬЗОВАНИЕ:
- Postgres MCP: проверка данных после операций с БД
- Git MCP: проверка статуса перед коммитом
- Memory MCP: сохранение архитектурного решения для premium модулей

КРИТЕРИИ ВАЛИДАЦИИ:
- Модуль компилируется без ошибок
- Все API endpoints работают корректно
- Swagger документация добавлена и актуальна
- Валидация работает для всех DTOs
- Обработка ошибок реализована

### Шаг 3: [Testing Agent] Написание тестов
КОНТЕКСТ:
- Связанные файлы:
  - backend/src/modules/premium-subscriptions/premium-subscriptions.service.spec.ts
  - backend/test/premium-subscriptions.e2e-spec.ts
- Похожие паттерны:
  - backend/src/modules/bookings/bookings.service.spec.ts

ТРЕБОВАНИЯ:
- Написать unit тесты для premium-subscriptions.service.ts:
  - Тест создания подписки
  - Тест обновления подписки
  - Тест отмены подписки
  - Тест проверки статуса подписки
  - Тест обработки истекших подписок
- Написать E2E тесты для API endpoints:
  - GET /premium/subscription
  - POST /premium/subscription
  - PATCH /premium/subscription
  - DELETE /premium/subscription
- Достичь покрытия кода >= 80%

MCP ИСПОЛЬЗОВАНИЕ:
- Postgres MCP: проверка тестовых данных после выполнения тестов
- Git MCP: проверка статуса перед коммитом
- Memory MCP: сохранение результатов тестирования

КРИТЕРИИ ВАЛИДАЦИИ:
- Все unit тесты проходят
- Все E2E тесты проходят
- Покрытие кода >= 80%
- Тесты проверяют edge cases (null, expired, cancelled)

### Шаг 4: [Documentation Agent] Обновление документации
КОНТЕКСТ:
- Связанные файлы:
  - docs/api/premium-subscriptions.md
  - README.md
- Похожие паттерны:
  - docs/api/bookings.md

ТРЕБОВАНИЯ:
- Создать документацию для API endpoints:
  - Описание всех endpoints
  - Примеры запросов и ответов
  - Коды ошибок и их значения
- Обновить README.md с информацией о premium подписках
- Обновить Swagger документацию (уже добавлена в шаге 2)

MCP ИСПОЛЬЗОВАНИЕ:
- Git MCP: проверка статуса перед коммитом
- Memory MCP: сохранение структуры документации для будущих модулей

КРИТЕРИИ ВАЛИДАЦИИ:
- Документация создана и актуальна
- Примеры запросов и ответов корректны
- README.md обновлен
```

---

## Пример 2: Исправление бага (Backend + Testing)

```markdown
# План: Исправление бага с дублированием медиа в постах

## Анализ задачи
- Тип задачи: Backend + Testing
- Необходимые агенты: Backend Agent, Database Agent, Testing Agent
- Критичные операции: Postgres (проверка данных), Git (коммит исправлений)
- Оценка времени: 2-3 часа

## План выполнения

### Шаг 1: [Database Agent] Анализ проблемы
КОНТЕКСТ:
- Связанные файлы:
  - backend/src/modules/posts/posts.service.ts
  - backend/src/modules/posts/entities/post.entity.ts
  - backend/src/modules/posts/entities/post-media.entity.ts
- Похожие паттерны:
  - Существующие паттерны сохранения связанных данных

ТРЕБОВАНИЯ:
- Проанализировать логику сохранения медиа в posts.service.ts
- Проверить настройки cascade в post.entity.ts
- Выявить причину дублирования медиа объектов

MCP ИСПОЛЬЗОВАНИЕ:
- Postgres MCP: проверка данных в таблице post_media для выявления дубликатов
- Postgres MCP: анализ структуры таблиц для понимания связей
- Memory MCP: сохранение результатов анализа для будущих исправлений

КРИТЕРИИ ВАЛИДАЦИИ:
- Причина дублирования выявлена
- Понимание текущей логики сохранения
- Результаты анализа сохранены

### Шаг 2: [Backend Agent] Исправление логики сохранения
КОНТЕКСТ:
- Связанные файлы:
  - backend/src/modules/posts/posts.service.ts
  - backend/src/modules/posts/entities/post.entity.ts
- Похожие паттерны:
  - Использование транзакций для атомарных операций

ТРЕБОВАНИЯ:
- Отключить cascade: true в post.entity.ts для relation media
- Обернуть сохранение поста и медиа в транзакцию
- Сохранять медиа явно через postMediaRepository.save()
- Убедиться, что медиа сохраняется только один раз

MCP ИСПОЛЬЗОВАНИЕ:
- Postgres MCP: проверка структуры БД перед изменением cascade
- Postgres MCP: проверка данных после исправления (не должно быть дубликатов)
- Git MCP: проверка статуса перед коммитом

КРИТЕРИИ ВАЛИДАЦИИ:
- Cascade отключен корректно
- Транзакция работает правильно
- Медиа сохраняется только один раз
- Нет дубликатов в БД

### Шаг 3: [Testing Agent] Написание теста для проверки исправления
КОНТЕКСТ:
- Связанные файлы:
  - backend/src/modules/posts/posts.service.spec.ts
  - backend/test/posts.e2e-spec.ts
- Похожие паттерны:
  - Существующие тесты для создания постов

ТРЕБОВАНИЯ:
- Написать unit тест для проверки отсутствия дубликатов медиа:
  - Создать пост с медиа
  - Проверить, что медиа сохранено только один раз
  - Проверить, что все медиа связаны с правильным post_id
- Написать E2E тест для проверки API:
  - POST /api/v2/posts с медиа
  - Проверить ответ (не должно быть дубликатов в массиве media)

MCP ИСПОЛЬЗОВАНИЕ:
- Postgres MCP: проверка данных после выполнения тестов
- Git MCP: проверка статуса перед коммитом

КРИТЕРИИ ВАЛИДАЦИИ:
- Тест проходит успешно
- Дубликаты не создаются
- Все медиа связаны правильно
```

---

## Пример 3: Рефакторинг (Frontend + Testing + Documentation)

```markdown
# План: Рефакторинг экрана создания поста

## Анализ задачи
- Тип задачи: Frontend + Testing + Documentation
- Необходимые агенты: Frontend Agent, Testing Agent, Documentation Agent
- Критичные операции: Git (коммит изменений), Memory (сохранение архитектурных решений)
- Оценка времени: 4-6 часов

## План выполнения

### Шаг 1: [Frontend Agent] Анализ текущей реализации
КОНТЕКСТ:
- Связанные файлы:
  - frontend/lib/features/feed/screens/create_post_screen.dart
  - frontend/lib/core/providers/api/feed_provider.dart
- Похожие паттерны:
  - Другие экраны создания контента

ТРЕБОВАНИЯ:
- Проанализировать текущую реализацию create_post_screen.dart
- Выявить проблемы и места для улучшения:
  - Дублирование кода
  - Сложная логика в одном файле
  - Отсутствие переиспользуемых компонентов
- Определить структуру рефакторинга

MCP ИСПОЛЬЗОВАНИЕ:
- Filesystem MCP: анализ структуры файлов перед рефакторингом
- Git MCP: просмотр истории изменений для понимания контекста
- Memory MCP: сохранение результатов анализа

КРИТЕРИИ ВАЛИДАЦИИ:
- Проблемы выявлены и задокументированы
- План рефакторинга определен
- Понимание текущей структуры

### Шаг 2: [Frontend Agent] Выделение переиспользуемых компонентов
КОНТЕКСТ:
- Связанные файлы:
  - frontend/lib/shared/widgets/
- Похожие паттерны:
  - Существующие переиспользуемые виджеты

ТРЕБОВАНИЯ:
- Выделить переиспользуемые компоненты:
  - MediaPickerWidget (выбор медиа)
  - MediaPreviewWidget (предпросмотр медиа)
  - PostContentEditor (редактор текста поста)
- Создать виджеты в shared/widgets/
- Обновить create_post_screen.dart для использования новых компонентов

MCP ИСПОЛЬЗОВАНИЕ:
- Git MCP: проверка статуса перед коммитом
- Memory MCP: сохранение архитектурного решения для переиспользуемых компонентов

КРИТЕРИИ ВАЛИДАЦИИ:
- Компоненты созданы и работают
- create_post_screen.dart обновлен
- Код стал более модульным
- Нет дублирования кода

### Шаг 3: [Frontend Agent] Рефакторинг логики состояния
КОНТЕКСТ:
- Связанные файлы:
  - frontend/lib/core/providers/api/feed_provider.dart
- Похожие паттерны:
  - Другие провайдеры в проекте

ТРЕБОВАНИЯ:
- Выделить логику создания поста в отдельный провайдер
- Создать createPostProvider для управления состоянием создания поста
- Упростить логику в create_post_screen.dart
- Использовать Riverpod best practices

MCP ИСПОЛЬЗОВАНИЕ:
- Git MCP: проверка статуса перед коммитом
- Memory MCP: сохранение архитектурного решения для state management

КРИТЕРИИ ВАЛИДАЦИИ:
- Провайдер создан и работает
- Логика упрощена
- Соответствует Riverpod best practices
- Нет утечек памяти

### Шаг 4: [Testing Agent] Обновление тестов
КОНТЕКСТ:
- Связанные файлы:
  - frontend/test/features/feed/create_post_screen_test.dart
- Похожие паттерны:
  - Существующие widget тесты

ТРЕБОВАНИЯ:
- Обновить существующие тесты для новых компонентов
- Написать тесты для новых виджетов:
  - MediaPickerWidget
  - MediaPreviewWidget
  - PostContentEditor
- Написать тесты для createPostProvider
- Убедиться, что все тесты проходят

MCP ИСПОЛЬЗОВАНИЕ:
- Git MCP: проверка статуса перед коммитом
- Memory MCP: сохранение результатов тестирования

КРИТЕРИИ ВАЛИДАЦИИ:
- Все тесты проходят
- Покрытие кода не уменьшилось
- Новые компоненты покрыты тестами

### Шаг 5: [Documentation Agent] Обновление документации
КОНТЕКСТ:
- Связанные файлы:
  - docs/architecture/frontend.md
  - README.md
- Похожие паттерны:
  - Существующая документация

ТРЕБОВАНИЯ:
- Обновить документацию по архитектуре Frontend
- Добавить описание новых переиспользуемых компонентов
- Обновить README.md с информацией о рефакторинге
- Добавить примеры использования новых компонентов

MCP ИСПОЛЬЗОВАНИЕ:
- Git MCP: проверка статуса перед коммитом
- Memory MCP: сохранение структуры документации

КРИТЕРИИ ВАЛИДАЦИИ:
- Документация обновлена и актуальна
- Примеры использования добавлены
- README.md обновлен
```

---

## Пример 4: Оптимизация БД (Database + Backend)

```markdown
# План: Оптимизация запросов для ленты постов

## Анализ задачи
- Тип задачи: Database + Backend
- Необходимые агенты: Database Agent, Backend Agent
- Критичные операции: Postgres (анализ запросов, создание индексов), Git (коммит изменений)
- Оценка времени: 3-4 часа

## План выполнения

### Шаг 1: [Database Agent] Анализ производительности запросов
КОНТЕКСТ:
- Связанные файлы:
  - backend/src/modules/posts/posts.service.ts
- Похожие паттерны:
  - Существующие оптимизированные запросы

ТРЕБОВАНИЯ:
- Проанализировать запросы для получения ленты постов
- Использовать EXPLAIN ANALYZE для выявления узких мест
- Определить необходимые индексы
- Измерить текущую производительность

MCP ИСПОЛЬЗОВАНИЕ:
- Postgres MCP: анализ выполнения запросов (EXPLAIN ANALYZE)
- Postgres MCP: проверка существующих индексов
- Memory MCP: сохранение результатов анализа

КРИТЕРИИ ВАЛИДАЦИИ:
- Узкие места выявлены
- Необходимые индексы определены
- Текущая производительность измерена
- Результаты анализа сохранены

### Шаг 2: [Database Agent] Создание индексов
КОНТЕКСТ:
- Связанные файлы:
  - backend/src/database/migrations/
- Похожие паттерны:
  - Существующие миграции с индексами

ТРЕБОВАНИЯ:
- Создать миграцию для добавления индексов:
  - Индекс на posts.created_at для сортировки
  - Индекс на posts.author_id для фильтрации
  - Составной индекс на (author_id, created_at) для комбинированных запросов
- Протестировать влияние индексов на производительность

MCP ИСПОЛЬЗОВАНИЕ:
- Postgres MCP: проверка структуры таблиц перед созданием индексов
- Postgres MCP: проверка производительности после создания индексов
- Git MCP: проверка статуса перед коммитом миграции

КРИТЕРИИ ВАЛИДАЦИИ:
- Миграция выполняется без ошибок
- Индексы созданы корректно
- Производительность улучшена
- Нет негативного влияния на другие запросы

### Шаг 3: [Backend Agent] Оптимизация запросов
КОНТЕКСТ:
- Связанные файлы:
  - backend/src/modules/posts/posts.service.ts
- Похожие паттерны:
  - Оптимизированные запросы в других модулях

ТРЕБОВАНИЯ:
- Оптимизировать запросы в posts.service.ts:
  - Использовать eager loading для связанных данных (author, media)
  - Добавить пагинацию для больших списков
  - Использовать QueryBuilder для сложных запросов
  - Избегать N+1 проблем
- Протестировать производительность после оптимизации

MCP ИСПОЛЬЗОВАНИЕ:
- Postgres MCP: проверка производительности после оптимизации
- Postgres MCP: анализ выполнения оптимизированных запросов
- Git MCP: проверка статуса перед коммитом
- Memory MCP: сохранение результатов оптимизации

КРИТЕРИИ ВАЛИДАЦИИ:
- Запросы выполняются быстрее
- Используются индексы эффективно
- Пагинация работает корректно
- Нет N+1 проблем
- Производительность улучшена минимум на 50%
```

---

## Best Practices из примеров

### 1. Всегда начинай с анализа
- ✅ Анализируй текущую реализацию перед изменениями
- ✅ Используй MCP для проверки текущего состояния
- ✅ Сохраняй результаты анализа в Memory MCP

### 2. Используй MCP для критичных операций
- ✅ Postgres MCP для всех операций с БД
- ✅ Git MCP для всех операций с Git
- ✅ Memory MCP для сохранения контекста

### 3. Структурируй план по шагам
- ✅ Каждый шаг явно делегирован агенту
- ✅ Каждый шаг имеет четкие критерии валидации
- ✅ Использование MCP указано явно

### 4. Тестируй после изменений
- ✅ Всегда включай Testing Agent в план
- ✅ Проверяй результаты через MCP
- ✅ Сохраняй результаты тестирования

---

## Дополнительные ресурсы

- [Шаблон плана](plan-template.md)
- [Полное руководство по режиму планирования](../CURSOR_PLAN_MODE.md)
- [Система оркестрации задач](../CURSOR_ORCHESTRATION.md)
